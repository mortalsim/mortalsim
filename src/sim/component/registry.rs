
/*
 * THIS FILE IS AUTOMATICALLY GENERATED.
 * SOURCE: scripts/registry_generator.js
 */

use std::marker::PhantomData;
use std::collections::HashSet;
use crate::sim::organism::Organism;
use crate::sim::layer::{
    LayerType,
    CoreComponent,
    CoreInitializer,
    CoreConnector,
    CirculationComponent,
    CirculationInitializer,
    CirculationConnector,
    DigestionComponent,
    DigestionInitializer,
    DigestionConnector,
    NervousComponent,
    NervousInitializer,
    NervousConnector,
};
use super::SimComponent;

pub trait ComponentWrapper<O: Organism>: SimComponent<O> + CoreComponent<O> + CirculationComponent<O> + DigestionComponent<O> + NervousComponent<O> {

    fn is_core_component(&self) -> bool;

    fn is_circulation_component(&self) -> bool;

    fn is_digestion_component(&self) -> bool;

    fn is_nervous_component(&self) -> bool;

    fn has_layer(&self, layer_type: &LayerType) -> bool;
}

impl<O: Organism> ComponentWrapper<O> for Box<dyn ComponentWrapper<O>> {

    fn is_core_component(&self) -> bool {
        self.as_ref().is_core_component()
    }

    fn is_circulation_component(&self) -> bool {
        self.as_ref().is_circulation_component()
    }

    fn is_digestion_component(&self) -> bool {
        self.as_ref().is_digestion_component()
    }

    fn is_nervous_component(&self) -> bool {
        self.as_ref().is_nervous_component()
    }

    fn has_layer(&self, layer_type: &LayerType) -> bool {
        self.as_ref().has_layer(layer_type)
    }
}

impl<O: Organism> SimComponent<O> for Box<dyn ComponentWrapper<O>> {
    fn id(&self) -> &'static str {
        self.as_ref().id()
    }
    fn attach(self, _registry: &mut ComponentRegistry<O>) {
        panic!("Can't reattach a boxed component wrapper")
    }
    fn run(&mut self) {
        self.as_mut().run()     
    }
}

impl<O: Organism> CoreComponent<O> for Box<dyn ComponentWrapper<O>> {
    fn core_init(&mut self, initializer: &mut CoreInitializer<O>) {
        self.as_mut().core_init(initializer) 
    }
    fn core_connector(&mut self) -> &mut CoreConnector<O> {
        self.as_mut().core_connector() 
    }
}
impl<O: Organism> CirculationComponent<O> for Box<dyn ComponentWrapper<O>> {
    fn circulation_init(&mut self, initializer: &mut CirculationInitializer<O>) {
        self.as_mut().circulation_init(initializer) 
    }
    fn circulation_connector(&mut self) -> &mut CirculationConnector<O> {
        self.as_mut().circulation_connector() 
    }
}
impl<O: Organism> DigestionComponent<O> for Box<dyn ComponentWrapper<O>> {
    fn digestion_init(&mut self, initializer: &mut DigestionInitializer<O>) {
        self.as_mut().digestion_init(initializer) 
    }
    fn digestion_connector(&mut self) -> &mut DigestionConnector<O> {
        self.as_mut().digestion_connector() 
    }
}
impl<O: Organism> NervousComponent<O> for Box<dyn ComponentWrapper<O>> {
    fn nervous_init(&mut self, initializer: &mut NervousInitializer<O>) {
        self.as_mut().nervous_init(initializer) 
    }
    fn nervous_connector(&mut self) -> &mut NervousConnector<O> {
        self.as_mut().nervous_connector() 
    }
}

pub struct CoreCirculationDigestionWrapper<O: Organism, T: Send + CoreComponent<O> + CirculationComponent<O> + DigestionComponent<O> + 'static>(pub T, pub PhantomData<O>);

impl<O: Organism + 'static, T: Send + CoreComponent<O> + CirculationComponent<O> + DigestionComponent<O>> SimComponent<O> for CoreCirculationDigestionWrapper<O, T> {
    fn id(&self) -> &'static str {
        self.0.id()
    }
    fn attach(self, registry: &mut ComponentRegistry<O>) {
        self.0.attach(registry)
    }
    fn run(&mut self) {
        self.0.run();
    }
}


impl<O: Organism + 'static, T: Send + CoreComponent<O> + CirculationComponent<O> + DigestionComponent<O>> CoreComponent<O> for CoreCirculationDigestionWrapper<O, T> {
    fn core_init(&mut self, initializer: &mut CoreInitializer<O>) {
        self.0.core_init(initializer)
    }
    fn core_connector(&mut self) -> &mut CoreConnector<O> {
        self.0.core_connector()
    }
}

impl<O: Organism + 'static, T: Send + CoreComponent<O> + CirculationComponent<O> + DigestionComponent<O>> CirculationComponent<O> for CoreCirculationDigestionWrapper<O, T> {
    fn circulation_init(&mut self, initializer: &mut CirculationInitializer<O>) {
        self.0.circulation_init(initializer)
    }
    fn circulation_connector(&mut self) -> &mut CirculationConnector<O> {
        self.0.circulation_connector()
    }
}

impl<O: Organism + 'static, T: Send + CoreComponent<O> + CirculationComponent<O> + DigestionComponent<O>> DigestionComponent<O> for CoreCirculationDigestionWrapper<O, T> {
    fn digestion_init(&mut self, initializer: &mut DigestionInitializer<O>) {
        self.0.digestion_init(initializer)
    }
    fn digestion_connector(&mut self) -> &mut DigestionConnector<O> {
        self.0.digestion_connector()
    }
}



impl<O: Organism + 'static, T: Send + CoreComponent<O> + CirculationComponent<O> + DigestionComponent<O>> NervousComponent<O> for CoreCirculationDigestionWrapper<O, T> {
    fn nervous_init(&mut self, _initializer: &mut NervousInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn nervous_connector(&mut self) -> &mut NervousConnector<O> {
        panic!("Improper wrapper method called!")
    }
}


impl<O: Organism + 'static, T: Send + CoreComponent<O> + CirculationComponent<O> + DigestionComponent<O>> ComponentWrapper<O> for CoreCirculationDigestionWrapper<O,T> {

    fn is_core_component(&self) -> bool {
        true
    }

    fn is_circulation_component(&self) -> bool {
        true
    }

    fn is_digestion_component(&self) -> bool {
        true
    }

    fn is_nervous_component(&self) -> bool {
        false
    }

    fn has_layer(&self, layer_type: &LayerType) -> bool {
        match layer_type {

            LayerType::Core => true,

            LayerType::Circulation => true,

            LayerType::Digestion => true,

            LayerType::Nervous => false,

        }
    }
}

pub struct CoreCirculationNervousWrapper<O: Organism, T: Send + CoreComponent<O> + CirculationComponent<O> + NervousComponent<O> + 'static>(pub T, pub PhantomData<O>);

impl<O: Organism + 'static, T: Send + CoreComponent<O> + CirculationComponent<O> + NervousComponent<O>> SimComponent<O> for CoreCirculationNervousWrapper<O, T> {
    fn id(&self) -> &'static str {
        self.0.id()
    }
    fn attach(self, registry: &mut ComponentRegistry<O>) {
        self.0.attach(registry)
    }
    fn run(&mut self) {
        self.0.run();
    }
}


impl<O: Organism + 'static, T: Send + CoreComponent<O> + CirculationComponent<O> + NervousComponent<O>> CoreComponent<O> for CoreCirculationNervousWrapper<O, T> {
    fn core_init(&mut self, initializer: &mut CoreInitializer<O>) {
        self.0.core_init(initializer)
    }
    fn core_connector(&mut self) -> &mut CoreConnector<O> {
        self.0.core_connector()
    }
}

impl<O: Organism + 'static, T: Send + CoreComponent<O> + CirculationComponent<O> + NervousComponent<O>> CirculationComponent<O> for CoreCirculationNervousWrapper<O, T> {
    fn circulation_init(&mut self, initializer: &mut CirculationInitializer<O>) {
        self.0.circulation_init(initializer)
    }
    fn circulation_connector(&mut self) -> &mut CirculationConnector<O> {
        self.0.circulation_connector()
    }
}

impl<O: Organism + 'static, T: Send + CoreComponent<O> + CirculationComponent<O> + NervousComponent<O>> NervousComponent<O> for CoreCirculationNervousWrapper<O, T> {
    fn nervous_init(&mut self, initializer: &mut NervousInitializer<O>) {
        self.0.nervous_init(initializer)
    }
    fn nervous_connector(&mut self) -> &mut NervousConnector<O> {
        self.0.nervous_connector()
    }
}



impl<O: Organism + 'static, T: Send + CoreComponent<O> + CirculationComponent<O> + NervousComponent<O>> DigestionComponent<O> for CoreCirculationNervousWrapper<O, T> {
    fn digestion_init(&mut self, _initializer: &mut DigestionInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn digestion_connector(&mut self) -> &mut DigestionConnector<O> {
        panic!("Improper wrapper method called!")
    }
}


impl<O: Organism + 'static, T: Send + CoreComponent<O> + CirculationComponent<O> + NervousComponent<O>> ComponentWrapper<O> for CoreCirculationNervousWrapper<O,T> {

    fn is_core_component(&self) -> bool {
        true
    }

    fn is_circulation_component(&self) -> bool {
        true
    }

    fn is_digestion_component(&self) -> bool {
        false
    }

    fn is_nervous_component(&self) -> bool {
        true
    }

    fn has_layer(&self, layer_type: &LayerType) -> bool {
        match layer_type {

            LayerType::Core => true,

            LayerType::Circulation => true,

            LayerType::Digestion => false,

            LayerType::Nervous => true,

        }
    }
}

pub struct CoreCirculationWrapper<O: Organism, T: Send + CoreComponent<O> + CirculationComponent<O> + 'static>(pub T, pub PhantomData<O>);

impl<O: Organism + 'static, T: Send + CoreComponent<O> + CirculationComponent<O>> SimComponent<O> for CoreCirculationWrapper<O, T> {
    fn id(&self) -> &'static str {
        self.0.id()
    }
    fn attach(self, registry: &mut ComponentRegistry<O>) {
        self.0.attach(registry)
    }
    fn run(&mut self) {
        self.0.run();
    }
}


impl<O: Organism + 'static, T: Send + CoreComponent<O> + CirculationComponent<O>> CoreComponent<O> for CoreCirculationWrapper<O, T> {
    fn core_init(&mut self, initializer: &mut CoreInitializer<O>) {
        self.0.core_init(initializer)
    }
    fn core_connector(&mut self) -> &mut CoreConnector<O> {
        self.0.core_connector()
    }
}

impl<O: Organism + 'static, T: Send + CoreComponent<O> + CirculationComponent<O>> CirculationComponent<O> for CoreCirculationWrapper<O, T> {
    fn circulation_init(&mut self, initializer: &mut CirculationInitializer<O>) {
        self.0.circulation_init(initializer)
    }
    fn circulation_connector(&mut self) -> &mut CirculationConnector<O> {
        self.0.circulation_connector()
    }
}



impl<O: Organism + 'static, T: Send + CoreComponent<O> + CirculationComponent<O>> DigestionComponent<O> for CoreCirculationWrapper<O, T> {
    fn digestion_init(&mut self, _initializer: &mut DigestionInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn digestion_connector(&mut self) -> &mut DigestionConnector<O> {
        panic!("Improper wrapper method called!")
    }
}

impl<O: Organism + 'static, T: Send + CoreComponent<O> + CirculationComponent<O>> NervousComponent<O> for CoreCirculationWrapper<O, T> {
    fn nervous_init(&mut self, _initializer: &mut NervousInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn nervous_connector(&mut self) -> &mut NervousConnector<O> {
        panic!("Improper wrapper method called!")
    }
}


impl<O: Organism + 'static, T: Send + CoreComponent<O> + CirculationComponent<O>> ComponentWrapper<O> for CoreCirculationWrapper<O,T> {

    fn is_core_component(&self) -> bool {
        true
    }

    fn is_circulation_component(&self) -> bool {
        true
    }

    fn is_digestion_component(&self) -> bool {
        false
    }

    fn is_nervous_component(&self) -> bool {
        false
    }

    fn has_layer(&self, layer_type: &LayerType) -> bool {
        match layer_type {

            LayerType::Core => true,

            LayerType::Circulation => true,

            LayerType::Digestion => false,

            LayerType::Nervous => false,

        }
    }
}

pub struct CoreDigestionNervousWrapper<O: Organism, T: Send + CoreComponent<O> + DigestionComponent<O> + NervousComponent<O> + 'static>(pub T, pub PhantomData<O>);

impl<O: Organism + 'static, T: Send + CoreComponent<O> + DigestionComponent<O> + NervousComponent<O>> SimComponent<O> for CoreDigestionNervousWrapper<O, T> {
    fn id(&self) -> &'static str {
        self.0.id()
    }
    fn attach(self, registry: &mut ComponentRegistry<O>) {
        self.0.attach(registry)
    }
    fn run(&mut self) {
        self.0.run();
    }
}


impl<O: Organism + 'static, T: Send + CoreComponent<O> + DigestionComponent<O> + NervousComponent<O>> CoreComponent<O> for CoreDigestionNervousWrapper<O, T> {
    fn core_init(&mut self, initializer: &mut CoreInitializer<O>) {
        self.0.core_init(initializer)
    }
    fn core_connector(&mut self) -> &mut CoreConnector<O> {
        self.0.core_connector()
    }
}

impl<O: Organism + 'static, T: Send + CoreComponent<O> + DigestionComponent<O> + NervousComponent<O>> DigestionComponent<O> for CoreDigestionNervousWrapper<O, T> {
    fn digestion_init(&mut self, initializer: &mut DigestionInitializer<O>) {
        self.0.digestion_init(initializer)
    }
    fn digestion_connector(&mut self) -> &mut DigestionConnector<O> {
        self.0.digestion_connector()
    }
}

impl<O: Organism + 'static, T: Send + CoreComponent<O> + DigestionComponent<O> + NervousComponent<O>> NervousComponent<O> for CoreDigestionNervousWrapper<O, T> {
    fn nervous_init(&mut self, initializer: &mut NervousInitializer<O>) {
        self.0.nervous_init(initializer)
    }
    fn nervous_connector(&mut self) -> &mut NervousConnector<O> {
        self.0.nervous_connector()
    }
}



impl<O: Organism + 'static, T: Send + CoreComponent<O> + DigestionComponent<O> + NervousComponent<O>> CirculationComponent<O> for CoreDigestionNervousWrapper<O, T> {
    fn circulation_init(&mut self, _initializer: &mut CirculationInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn circulation_connector(&mut self) -> &mut CirculationConnector<O> {
        panic!("Improper wrapper method called!")
    }
}


impl<O: Organism + 'static, T: Send + CoreComponent<O> + DigestionComponent<O> + NervousComponent<O>> ComponentWrapper<O> for CoreDigestionNervousWrapper<O,T> {

    fn is_core_component(&self) -> bool {
        true
    }

    fn is_circulation_component(&self) -> bool {
        false
    }

    fn is_digestion_component(&self) -> bool {
        true
    }

    fn is_nervous_component(&self) -> bool {
        true
    }

    fn has_layer(&self, layer_type: &LayerType) -> bool {
        match layer_type {

            LayerType::Core => true,

            LayerType::Circulation => false,

            LayerType::Digestion => true,

            LayerType::Nervous => true,

        }
    }
}

pub struct CoreDigestionWrapper<O: Organism, T: Send + CoreComponent<O> + DigestionComponent<O> + 'static>(pub T, pub PhantomData<O>);

impl<O: Organism + 'static, T: Send + CoreComponent<O> + DigestionComponent<O>> SimComponent<O> for CoreDigestionWrapper<O, T> {
    fn id(&self) -> &'static str {
        self.0.id()
    }
    fn attach(self, registry: &mut ComponentRegistry<O>) {
        self.0.attach(registry)
    }
    fn run(&mut self) {
        self.0.run();
    }
}


impl<O: Organism + 'static, T: Send + CoreComponent<O> + DigestionComponent<O>> CoreComponent<O> for CoreDigestionWrapper<O, T> {
    fn core_init(&mut self, initializer: &mut CoreInitializer<O>) {
        self.0.core_init(initializer)
    }
    fn core_connector(&mut self) -> &mut CoreConnector<O> {
        self.0.core_connector()
    }
}

impl<O: Organism + 'static, T: Send + CoreComponent<O> + DigestionComponent<O>> DigestionComponent<O> for CoreDigestionWrapper<O, T> {
    fn digestion_init(&mut self, initializer: &mut DigestionInitializer<O>) {
        self.0.digestion_init(initializer)
    }
    fn digestion_connector(&mut self) -> &mut DigestionConnector<O> {
        self.0.digestion_connector()
    }
}



impl<O: Organism + 'static, T: Send + CoreComponent<O> + DigestionComponent<O>> CirculationComponent<O> for CoreDigestionWrapper<O, T> {
    fn circulation_init(&mut self, _initializer: &mut CirculationInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn circulation_connector(&mut self) -> &mut CirculationConnector<O> {
        panic!("Improper wrapper method called!")
    }
}

impl<O: Organism + 'static, T: Send + CoreComponent<O> + DigestionComponent<O>> NervousComponent<O> for CoreDigestionWrapper<O, T> {
    fn nervous_init(&mut self, _initializer: &mut NervousInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn nervous_connector(&mut self) -> &mut NervousConnector<O> {
        panic!("Improper wrapper method called!")
    }
}


impl<O: Organism + 'static, T: Send + CoreComponent<O> + DigestionComponent<O>> ComponentWrapper<O> for CoreDigestionWrapper<O,T> {

    fn is_core_component(&self) -> bool {
        true
    }

    fn is_circulation_component(&self) -> bool {
        false
    }

    fn is_digestion_component(&self) -> bool {
        true
    }

    fn is_nervous_component(&self) -> bool {
        false
    }

    fn has_layer(&self, layer_type: &LayerType) -> bool {
        match layer_type {

            LayerType::Core => true,

            LayerType::Circulation => false,

            LayerType::Digestion => true,

            LayerType::Nervous => false,

        }
    }
}

pub struct CoreNervousWrapper<O: Organism, T: Send + CoreComponent<O> + NervousComponent<O> + 'static>(pub T, pub PhantomData<O>);

impl<O: Organism + 'static, T: Send + CoreComponent<O> + NervousComponent<O>> SimComponent<O> for CoreNervousWrapper<O, T> {
    fn id(&self) -> &'static str {
        self.0.id()
    }
    fn attach(self, registry: &mut ComponentRegistry<O>) {
        self.0.attach(registry)
    }
    fn run(&mut self) {
        self.0.run();
    }
}


impl<O: Organism + 'static, T: Send + CoreComponent<O> + NervousComponent<O>> CoreComponent<O> for CoreNervousWrapper<O, T> {
    fn core_init(&mut self, initializer: &mut CoreInitializer<O>) {
        self.0.core_init(initializer)
    }
    fn core_connector(&mut self) -> &mut CoreConnector<O> {
        self.0.core_connector()
    }
}

impl<O: Organism + 'static, T: Send + CoreComponent<O> + NervousComponent<O>> NervousComponent<O> for CoreNervousWrapper<O, T> {
    fn nervous_init(&mut self, initializer: &mut NervousInitializer<O>) {
        self.0.nervous_init(initializer)
    }
    fn nervous_connector(&mut self) -> &mut NervousConnector<O> {
        self.0.nervous_connector()
    }
}



impl<O: Organism + 'static, T: Send + CoreComponent<O> + NervousComponent<O>> CirculationComponent<O> for CoreNervousWrapper<O, T> {
    fn circulation_init(&mut self, _initializer: &mut CirculationInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn circulation_connector(&mut self) -> &mut CirculationConnector<O> {
        panic!("Improper wrapper method called!")
    }
}

impl<O: Organism + 'static, T: Send + CoreComponent<O> + NervousComponent<O>> DigestionComponent<O> for CoreNervousWrapper<O, T> {
    fn digestion_init(&mut self, _initializer: &mut DigestionInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn digestion_connector(&mut self) -> &mut DigestionConnector<O> {
        panic!("Improper wrapper method called!")
    }
}


impl<O: Organism + 'static, T: Send + CoreComponent<O> + NervousComponent<O>> ComponentWrapper<O> for CoreNervousWrapper<O,T> {

    fn is_core_component(&self) -> bool {
        true
    }

    fn is_circulation_component(&self) -> bool {
        false
    }

    fn is_digestion_component(&self) -> bool {
        false
    }

    fn is_nervous_component(&self) -> bool {
        true
    }

    fn has_layer(&self, layer_type: &LayerType) -> bool {
        match layer_type {

            LayerType::Core => true,

            LayerType::Circulation => false,

            LayerType::Digestion => false,

            LayerType::Nervous => true,

        }
    }
}

pub struct CoreWrapper<O: Organism, T: Send + CoreComponent<O> + 'static>(pub T, pub PhantomData<O>);

impl<O: Organism + 'static, T: Send + CoreComponent<O>> SimComponent<O> for CoreWrapper<O, T> {
    fn id(&self) -> &'static str {
        self.0.id()
    }
    fn attach(self, registry: &mut ComponentRegistry<O>) {
        self.0.attach(registry)
    }
    fn run(&mut self) {
        self.0.run();
    }
}


impl<O: Organism + 'static, T: Send + CoreComponent<O>> CoreComponent<O> for CoreWrapper<O, T> {
    fn core_init(&mut self, initializer: &mut CoreInitializer<O>) {
        self.0.core_init(initializer)
    }
    fn core_connector(&mut self) -> &mut CoreConnector<O> {
        self.0.core_connector()
    }
}



impl<O: Organism + 'static, T: Send + CoreComponent<O>> CirculationComponent<O> for CoreWrapper<O, T> {
    fn circulation_init(&mut self, _initializer: &mut CirculationInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn circulation_connector(&mut self) -> &mut CirculationConnector<O> {
        panic!("Improper wrapper method called!")
    }
}

impl<O: Organism + 'static, T: Send + CoreComponent<O>> DigestionComponent<O> for CoreWrapper<O, T> {
    fn digestion_init(&mut self, _initializer: &mut DigestionInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn digestion_connector(&mut self) -> &mut DigestionConnector<O> {
        panic!("Improper wrapper method called!")
    }
}

impl<O: Organism + 'static, T: Send + CoreComponent<O>> NervousComponent<O> for CoreWrapper<O, T> {
    fn nervous_init(&mut self, _initializer: &mut NervousInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn nervous_connector(&mut self) -> &mut NervousConnector<O> {
        panic!("Improper wrapper method called!")
    }
}


impl<O: Organism + 'static, T: Send + CoreComponent<O>> ComponentWrapper<O> for CoreWrapper<O,T> {

    fn is_core_component(&self) -> bool {
        true
    }

    fn is_circulation_component(&self) -> bool {
        false
    }

    fn is_digestion_component(&self) -> bool {
        false
    }

    fn is_nervous_component(&self) -> bool {
        false
    }

    fn has_layer(&self, layer_type: &LayerType) -> bool {
        match layer_type {

            LayerType::Core => true,

            LayerType::Circulation => false,

            LayerType::Digestion => false,

            LayerType::Nervous => false,

        }
    }
}

pub struct CirculationDigestionNervousWrapper<O: Organism, T: Send + CirculationComponent<O> + DigestionComponent<O> + NervousComponent<O> + 'static>(pub T, pub PhantomData<O>);

impl<O: Organism + 'static, T: Send + CirculationComponent<O> + DigestionComponent<O> + NervousComponent<O>> SimComponent<O> for CirculationDigestionNervousWrapper<O, T> {
    fn id(&self) -> &'static str {
        self.0.id()
    }
    fn attach(self, registry: &mut ComponentRegistry<O>) {
        self.0.attach(registry)
    }
    fn run(&mut self) {
        self.0.run();
    }
}


impl<O: Organism + 'static, T: Send + CirculationComponent<O> + DigestionComponent<O> + NervousComponent<O>> CirculationComponent<O> for CirculationDigestionNervousWrapper<O, T> {
    fn circulation_init(&mut self, initializer: &mut CirculationInitializer<O>) {
        self.0.circulation_init(initializer)
    }
    fn circulation_connector(&mut self) -> &mut CirculationConnector<O> {
        self.0.circulation_connector()
    }
}

impl<O: Organism + 'static, T: Send + CirculationComponent<O> + DigestionComponent<O> + NervousComponent<O>> DigestionComponent<O> for CirculationDigestionNervousWrapper<O, T> {
    fn digestion_init(&mut self, initializer: &mut DigestionInitializer<O>) {
        self.0.digestion_init(initializer)
    }
    fn digestion_connector(&mut self) -> &mut DigestionConnector<O> {
        self.0.digestion_connector()
    }
}

impl<O: Organism + 'static, T: Send + CirculationComponent<O> + DigestionComponent<O> + NervousComponent<O>> NervousComponent<O> for CirculationDigestionNervousWrapper<O, T> {
    fn nervous_init(&mut self, initializer: &mut NervousInitializer<O>) {
        self.0.nervous_init(initializer)
    }
    fn nervous_connector(&mut self) -> &mut NervousConnector<O> {
        self.0.nervous_connector()
    }
}



impl<O: Organism + 'static, T: Send + CirculationComponent<O> + DigestionComponent<O> + NervousComponent<O>> CoreComponent<O> for CirculationDigestionNervousWrapper<O, T> {
    fn core_init(&mut self, _initializer: &mut CoreInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn core_connector(&mut self) -> &mut CoreConnector<O> {
        panic!("Improper wrapper method called!")
    }
}


impl<O: Organism + 'static, T: Send + CirculationComponent<O> + DigestionComponent<O> + NervousComponent<O>> ComponentWrapper<O> for CirculationDigestionNervousWrapper<O,T> {

    fn is_core_component(&self) -> bool {
        false
    }

    fn is_circulation_component(&self) -> bool {
        true
    }

    fn is_digestion_component(&self) -> bool {
        true
    }

    fn is_nervous_component(&self) -> bool {
        true
    }

    fn has_layer(&self, layer_type: &LayerType) -> bool {
        match layer_type {

            LayerType::Core => false,

            LayerType::Circulation => true,

            LayerType::Digestion => true,

            LayerType::Nervous => true,

        }
    }
}

pub struct CirculationDigestionWrapper<O: Organism, T: Send + CirculationComponent<O> + DigestionComponent<O> + 'static>(pub T, pub PhantomData<O>);

impl<O: Organism + 'static, T: Send + CirculationComponent<O> + DigestionComponent<O>> SimComponent<O> for CirculationDigestionWrapper<O, T> {
    fn id(&self) -> &'static str {
        self.0.id()
    }
    fn attach(self, registry: &mut ComponentRegistry<O>) {
        self.0.attach(registry)
    }
    fn run(&mut self) {
        self.0.run();
    }
}


impl<O: Organism + 'static, T: Send + CirculationComponent<O> + DigestionComponent<O>> CirculationComponent<O> for CirculationDigestionWrapper<O, T> {
    fn circulation_init(&mut self, initializer: &mut CirculationInitializer<O>) {
        self.0.circulation_init(initializer)
    }
    fn circulation_connector(&mut self) -> &mut CirculationConnector<O> {
        self.0.circulation_connector()
    }
}

impl<O: Organism + 'static, T: Send + CirculationComponent<O> + DigestionComponent<O>> DigestionComponent<O> for CirculationDigestionWrapper<O, T> {
    fn digestion_init(&mut self, initializer: &mut DigestionInitializer<O>) {
        self.0.digestion_init(initializer)
    }
    fn digestion_connector(&mut self) -> &mut DigestionConnector<O> {
        self.0.digestion_connector()
    }
}



impl<O: Organism + 'static, T: Send + CirculationComponent<O> + DigestionComponent<O>> CoreComponent<O> for CirculationDigestionWrapper<O, T> {
    fn core_init(&mut self, _initializer: &mut CoreInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn core_connector(&mut self) -> &mut CoreConnector<O> {
        panic!("Improper wrapper method called!")
    }
}

impl<O: Organism + 'static, T: Send + CirculationComponent<O> + DigestionComponent<O>> NervousComponent<O> for CirculationDigestionWrapper<O, T> {
    fn nervous_init(&mut self, _initializer: &mut NervousInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn nervous_connector(&mut self) -> &mut NervousConnector<O> {
        panic!("Improper wrapper method called!")
    }
}


impl<O: Organism + 'static, T: Send + CirculationComponent<O> + DigestionComponent<O>> ComponentWrapper<O> for CirculationDigestionWrapper<O,T> {

    fn is_core_component(&self) -> bool {
        false
    }

    fn is_circulation_component(&self) -> bool {
        true
    }

    fn is_digestion_component(&self) -> bool {
        true
    }

    fn is_nervous_component(&self) -> bool {
        false
    }

    fn has_layer(&self, layer_type: &LayerType) -> bool {
        match layer_type {

            LayerType::Core => false,

            LayerType::Circulation => true,

            LayerType::Digestion => true,

            LayerType::Nervous => false,

        }
    }
}

pub struct CirculationNervousWrapper<O: Organism, T: Send + CirculationComponent<O> + NervousComponent<O> + 'static>(pub T, pub PhantomData<O>);

impl<O: Organism + 'static, T: Send + CirculationComponent<O> + NervousComponent<O>> SimComponent<O> for CirculationNervousWrapper<O, T> {
    fn id(&self) -> &'static str {
        self.0.id()
    }
    fn attach(self, registry: &mut ComponentRegistry<O>) {
        self.0.attach(registry)
    }
    fn run(&mut self) {
        self.0.run();
    }
}


impl<O: Organism + 'static, T: Send + CirculationComponent<O> + NervousComponent<O>> CirculationComponent<O> for CirculationNervousWrapper<O, T> {
    fn circulation_init(&mut self, initializer: &mut CirculationInitializer<O>) {
        self.0.circulation_init(initializer)
    }
    fn circulation_connector(&mut self) -> &mut CirculationConnector<O> {
        self.0.circulation_connector()
    }
}

impl<O: Organism + 'static, T: Send + CirculationComponent<O> + NervousComponent<O>> NervousComponent<O> for CirculationNervousWrapper<O, T> {
    fn nervous_init(&mut self, initializer: &mut NervousInitializer<O>) {
        self.0.nervous_init(initializer)
    }
    fn nervous_connector(&mut self) -> &mut NervousConnector<O> {
        self.0.nervous_connector()
    }
}



impl<O: Organism + 'static, T: Send + CirculationComponent<O> + NervousComponent<O>> CoreComponent<O> for CirculationNervousWrapper<O, T> {
    fn core_init(&mut self, _initializer: &mut CoreInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn core_connector(&mut self) -> &mut CoreConnector<O> {
        panic!("Improper wrapper method called!")
    }
}

impl<O: Organism + 'static, T: Send + CirculationComponent<O> + NervousComponent<O>> DigestionComponent<O> for CirculationNervousWrapper<O, T> {
    fn digestion_init(&mut self, _initializer: &mut DigestionInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn digestion_connector(&mut self) -> &mut DigestionConnector<O> {
        panic!("Improper wrapper method called!")
    }
}


impl<O: Organism + 'static, T: Send + CirculationComponent<O> + NervousComponent<O>> ComponentWrapper<O> for CirculationNervousWrapper<O,T> {

    fn is_core_component(&self) -> bool {
        false
    }

    fn is_circulation_component(&self) -> bool {
        true
    }

    fn is_digestion_component(&self) -> bool {
        false
    }

    fn is_nervous_component(&self) -> bool {
        true
    }

    fn has_layer(&self, layer_type: &LayerType) -> bool {
        match layer_type {

            LayerType::Core => false,

            LayerType::Circulation => true,

            LayerType::Digestion => false,

            LayerType::Nervous => true,

        }
    }
}

pub struct CirculationWrapper<O: Organism, T: Send + CirculationComponent<O> + 'static>(pub T, pub PhantomData<O>);

impl<O: Organism + 'static, T: Send + CirculationComponent<O>> SimComponent<O> for CirculationWrapper<O, T> {
    fn id(&self) -> &'static str {
        self.0.id()
    }
    fn attach(self, registry: &mut ComponentRegistry<O>) {
        self.0.attach(registry)
    }
    fn run(&mut self) {
        self.0.run();
    }
}


impl<O: Organism + 'static, T: Send + CirculationComponent<O>> CirculationComponent<O> for CirculationWrapper<O, T> {
    fn circulation_init(&mut self, initializer: &mut CirculationInitializer<O>) {
        self.0.circulation_init(initializer)
    }
    fn circulation_connector(&mut self) -> &mut CirculationConnector<O> {
        self.0.circulation_connector()
    }
}



impl<O: Organism + 'static, T: Send + CirculationComponent<O>> CoreComponent<O> for CirculationWrapper<O, T> {
    fn core_init(&mut self, _initializer: &mut CoreInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn core_connector(&mut self) -> &mut CoreConnector<O> {
        panic!("Improper wrapper method called!")
    }
}

impl<O: Organism + 'static, T: Send + CirculationComponent<O>> DigestionComponent<O> for CirculationWrapper<O, T> {
    fn digestion_init(&mut self, _initializer: &mut DigestionInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn digestion_connector(&mut self) -> &mut DigestionConnector<O> {
        panic!("Improper wrapper method called!")
    }
}

impl<O: Organism + 'static, T: Send + CirculationComponent<O>> NervousComponent<O> for CirculationWrapper<O, T> {
    fn nervous_init(&mut self, _initializer: &mut NervousInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn nervous_connector(&mut self) -> &mut NervousConnector<O> {
        panic!("Improper wrapper method called!")
    }
}


impl<O: Organism + 'static, T: Send + CirculationComponent<O>> ComponentWrapper<O> for CirculationWrapper<O,T> {

    fn is_core_component(&self) -> bool {
        false
    }

    fn is_circulation_component(&self) -> bool {
        true
    }

    fn is_digestion_component(&self) -> bool {
        false
    }

    fn is_nervous_component(&self) -> bool {
        false
    }

    fn has_layer(&self, layer_type: &LayerType) -> bool {
        match layer_type {

            LayerType::Core => false,

            LayerType::Circulation => true,

            LayerType::Digestion => false,

            LayerType::Nervous => false,

        }
    }
}

pub struct DigestionNervousWrapper<O: Organism, T: Send + DigestionComponent<O> + NervousComponent<O> + 'static>(pub T, pub PhantomData<O>);

impl<O: Organism + 'static, T: Send + DigestionComponent<O> + NervousComponent<O>> SimComponent<O> for DigestionNervousWrapper<O, T> {
    fn id(&self) -> &'static str {
        self.0.id()
    }
    fn attach(self, registry: &mut ComponentRegistry<O>) {
        self.0.attach(registry)
    }
    fn run(&mut self) {
        self.0.run();
    }
}


impl<O: Organism + 'static, T: Send + DigestionComponent<O> + NervousComponent<O>> DigestionComponent<O> for DigestionNervousWrapper<O, T> {
    fn digestion_init(&mut self, initializer: &mut DigestionInitializer<O>) {
        self.0.digestion_init(initializer)
    }
    fn digestion_connector(&mut self) -> &mut DigestionConnector<O> {
        self.0.digestion_connector()
    }
}

impl<O: Organism + 'static, T: Send + DigestionComponent<O> + NervousComponent<O>> NervousComponent<O> for DigestionNervousWrapper<O, T> {
    fn nervous_init(&mut self, initializer: &mut NervousInitializer<O>) {
        self.0.nervous_init(initializer)
    }
    fn nervous_connector(&mut self) -> &mut NervousConnector<O> {
        self.0.nervous_connector()
    }
}



impl<O: Organism + 'static, T: Send + DigestionComponent<O> + NervousComponent<O>> CoreComponent<O> for DigestionNervousWrapper<O, T> {
    fn core_init(&mut self, _initializer: &mut CoreInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn core_connector(&mut self) -> &mut CoreConnector<O> {
        panic!("Improper wrapper method called!")
    }
}

impl<O: Organism + 'static, T: Send + DigestionComponent<O> + NervousComponent<O>> CirculationComponent<O> for DigestionNervousWrapper<O, T> {
    fn circulation_init(&mut self, _initializer: &mut CirculationInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn circulation_connector(&mut self) -> &mut CirculationConnector<O> {
        panic!("Improper wrapper method called!")
    }
}


impl<O: Organism + 'static, T: Send + DigestionComponent<O> + NervousComponent<O>> ComponentWrapper<O> for DigestionNervousWrapper<O,T> {

    fn is_core_component(&self) -> bool {
        false
    }

    fn is_circulation_component(&self) -> bool {
        false
    }

    fn is_digestion_component(&self) -> bool {
        true
    }

    fn is_nervous_component(&self) -> bool {
        true
    }

    fn has_layer(&self, layer_type: &LayerType) -> bool {
        match layer_type {

            LayerType::Core => false,

            LayerType::Circulation => false,

            LayerType::Digestion => true,

            LayerType::Nervous => true,

        }
    }
}

pub struct DigestionWrapper<O: Organism, T: Send + DigestionComponent<O> + 'static>(pub T, pub PhantomData<O>);

impl<O: Organism + 'static, T: Send + DigestionComponent<O>> SimComponent<O> for DigestionWrapper<O, T> {
    fn id(&self) -> &'static str {
        self.0.id()
    }
    fn attach(self, registry: &mut ComponentRegistry<O>) {
        self.0.attach(registry)
    }
    fn run(&mut self) {
        self.0.run();
    }
}


impl<O: Organism + 'static, T: Send + DigestionComponent<O>> DigestionComponent<O> for DigestionWrapper<O, T> {
    fn digestion_init(&mut self, initializer: &mut DigestionInitializer<O>) {
        self.0.digestion_init(initializer)
    }
    fn digestion_connector(&mut self) -> &mut DigestionConnector<O> {
        self.0.digestion_connector()
    }
}



impl<O: Organism + 'static, T: Send + DigestionComponent<O>> CoreComponent<O> for DigestionWrapper<O, T> {
    fn core_init(&mut self, _initializer: &mut CoreInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn core_connector(&mut self) -> &mut CoreConnector<O> {
        panic!("Improper wrapper method called!")
    }
}

impl<O: Organism + 'static, T: Send + DigestionComponent<O>> CirculationComponent<O> for DigestionWrapper<O, T> {
    fn circulation_init(&mut self, _initializer: &mut CirculationInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn circulation_connector(&mut self) -> &mut CirculationConnector<O> {
        panic!("Improper wrapper method called!")
    }
}

impl<O: Organism + 'static, T: Send + DigestionComponent<O>> NervousComponent<O> for DigestionWrapper<O, T> {
    fn nervous_init(&mut self, _initializer: &mut NervousInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn nervous_connector(&mut self) -> &mut NervousConnector<O> {
        panic!("Improper wrapper method called!")
    }
}


impl<O: Organism + 'static, T: Send + DigestionComponent<O>> ComponentWrapper<O> for DigestionWrapper<O,T> {

    fn is_core_component(&self) -> bool {
        false
    }

    fn is_circulation_component(&self) -> bool {
        false
    }

    fn is_digestion_component(&self) -> bool {
        true
    }

    fn is_nervous_component(&self) -> bool {
        false
    }

    fn has_layer(&self, layer_type: &LayerType) -> bool {
        match layer_type {

            LayerType::Core => false,

            LayerType::Circulation => false,

            LayerType::Digestion => true,

            LayerType::Nervous => false,

        }
    }
}

pub struct NervousWrapper<O: Organism, T: Send + NervousComponent<O> + 'static>(pub T, pub PhantomData<O>);

impl<O: Organism + 'static, T: Send + NervousComponent<O>> SimComponent<O> for NervousWrapper<O, T> {
    fn id(&self) -> &'static str {
        self.0.id()
    }
    fn attach(self, registry: &mut ComponentRegistry<O>) {
        self.0.attach(registry)
    }
    fn run(&mut self) {
        self.0.run();
    }
}


impl<O: Organism + 'static, T: Send + NervousComponent<O>> NervousComponent<O> for NervousWrapper<O, T> {
    fn nervous_init(&mut self, initializer: &mut NervousInitializer<O>) {
        self.0.nervous_init(initializer)
    }
    fn nervous_connector(&mut self) -> &mut NervousConnector<O> {
        self.0.nervous_connector()
    }
}



impl<O: Organism + 'static, T: Send + NervousComponent<O>> CoreComponent<O> for NervousWrapper<O, T> {
    fn core_init(&mut self, _initializer: &mut CoreInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn core_connector(&mut self) -> &mut CoreConnector<O> {
        panic!("Improper wrapper method called!")
    }
}

impl<O: Organism + 'static, T: Send + NervousComponent<O>> CirculationComponent<O> for NervousWrapper<O, T> {
    fn circulation_init(&mut self, _initializer: &mut CirculationInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn circulation_connector(&mut self) -> &mut CirculationConnector<O> {
        panic!("Improper wrapper method called!")
    }
}

impl<O: Organism + 'static, T: Send + NervousComponent<O>> DigestionComponent<O> for NervousWrapper<O, T> {
    fn digestion_init(&mut self, _initializer: &mut DigestionInitializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn digestion_connector(&mut self) -> &mut DigestionConnector<O> {
        panic!("Improper wrapper method called!")
    }
}


impl<O: Organism + 'static, T: Send + NervousComponent<O>> ComponentWrapper<O> for NervousWrapper<O,T> {

    fn is_core_component(&self) -> bool {
        false
    }

    fn is_circulation_component(&self) -> bool {
        false
    }

    fn is_digestion_component(&self) -> bool {
        false
    }

    fn is_nervous_component(&self) -> bool {
        true
    }

    fn has_layer(&self, layer_type: &LayerType) -> bool {
        match layer_type {

            LayerType::Core => false,

            LayerType::Circulation => false,

            LayerType::Digestion => false,

            LayerType::Nervous => true,

        }
    }
}


pub struct ComponentRegistry<O: Organism> {
    id_set: HashSet<&'static str>,
    components: Vec<Box<dyn ComponentWrapper<O>>>,
}

impl<O: Organism + 'static> ComponentRegistry<O> {
    pub fn new() -> Self {
        Self {
            id_set: HashSet::new(),
            components: Vec::new(),
        }
    }

    pub(crate) fn add_component(&mut self, component: impl SimComponent<O>) -> anyhow::Result<&'_ dyn ComponentWrapper<O>> {
        if self.id_set.contains(&component.id()) {
            return Err(anyhow!("Component '{}' has already been registered!", component.id()))
        }
        self.id_set.insert(component.id());
        component.attach(self);
        Ok(self.components.last().unwrap().as_ref())
    }

    pub(crate) fn remove_component(&mut self, component_id: &str) -> anyhow::Result<Box<dyn ComponentWrapper<O>>> {
        if let Some(index) = self.components.iter().position(|x| x.id() == component_id) {
            return Ok(self.components.remove(index))
        }
        Err(anyhow!("component not found"))
    }

    pub(crate) fn has_component(&self, component_id: &str) -> bool {
        self.id_set.contains(component_id)
    }
    pub(crate) fn all_components(&self) -> impl Iterator<Item = &Box<dyn ComponentWrapper<O>>> {
        self.components.iter()
    }
    pub(crate) fn all_components_mut(&mut self) -> impl Iterator<Item = &mut Box<dyn ComponentWrapper<O>>> {
        self.components.iter_mut()
    }

    pub fn add_core_circulation_digestion_component(&mut self, component: impl CoreComponent<O> + CirculationComponent<O> + DigestionComponent<O> + 'static) {
        self.components.push(Box::new(CoreCirculationDigestionWrapper(component, PhantomData)))
    }

    pub fn add_core_circulation_nervous_component(&mut self, component: impl CoreComponent<O> + CirculationComponent<O> + NervousComponent<O> + 'static) {
        self.components.push(Box::new(CoreCirculationNervousWrapper(component, PhantomData)))
    }

    pub fn add_core_circulation_component(&mut self, component: impl CoreComponent<O> + CirculationComponent<O> + 'static) {
        self.components.push(Box::new(CoreCirculationWrapper(component, PhantomData)))
    }

    pub fn add_core_digestion_nervous_component(&mut self, component: impl CoreComponent<O> + DigestionComponent<O> + NervousComponent<O> + 'static) {
        self.components.push(Box::new(CoreDigestionNervousWrapper(component, PhantomData)))
    }

    pub fn add_core_digestion_component(&mut self, component: impl CoreComponent<O> + DigestionComponent<O> + 'static) {
        self.components.push(Box::new(CoreDigestionWrapper(component, PhantomData)))
    }

    pub fn add_core_nervous_component(&mut self, component: impl CoreComponent<O> + NervousComponent<O> + 'static) {
        self.components.push(Box::new(CoreNervousWrapper(component, PhantomData)))
    }

    pub fn add_core_component(&mut self, component: impl CoreComponent<O> + 'static) {
        self.components.push(Box::new(CoreWrapper(component, PhantomData)))
    }

    pub fn add_circulation_digestion_nervous_component(&mut self, component: impl CirculationComponent<O> + DigestionComponent<O> + NervousComponent<O> + 'static) {
        self.components.push(Box::new(CirculationDigestionNervousWrapper(component, PhantomData)))
    }

    pub fn add_circulation_digestion_component(&mut self, component: impl CirculationComponent<O> + DigestionComponent<O> + 'static) {
        self.components.push(Box::new(CirculationDigestionWrapper(component, PhantomData)))
    }

    pub fn add_circulation_nervous_component(&mut self, component: impl CirculationComponent<O> + NervousComponent<O> + 'static) {
        self.components.push(Box::new(CirculationNervousWrapper(component, PhantomData)))
    }

    pub fn add_circulation_component(&mut self, component: impl CirculationComponent<O> + 'static) {
        self.components.push(Box::new(CirculationWrapper(component, PhantomData)))
    }

    pub fn add_digestion_nervous_component(&mut self, component: impl DigestionComponent<O> + NervousComponent<O> + 'static) {
        self.components.push(Box::new(DigestionNervousWrapper(component, PhantomData)))
    }

    pub fn add_digestion_component(&mut self, component: impl DigestionComponent<O> + 'static) {
        self.components.push(Box::new(DigestionWrapper(component, PhantomData)))
    }

    pub fn add_nervous_component(&mut self, component: impl NervousComponent<O> + 'static) {
        self.components.push(Box::new(NervousWrapper(component, PhantomData)))
    }

}
