const yaml = require('yaml');
const fs = require('fs');
const path = require('path');

const configPath = path.join(__dirname, '..', 'config');

fs.readdirSync(configPath)
    .filter(f => fs.statSync(path.join(configPath, f)).isDirectory())
    .forEach(dir => {
        console.log(dir);
        let configFile = fs.readFileSync(path.join(configPath, dir, 'nervous_system.yaml'), 'utf8');
        let config = yaml.parse(configFile);
        writeNeuralFile(dir, config);
    });

function writeNeuralFile(namespace, config) {
    const namespaceCapitalized = namespace.charAt(0).toUpperCase() + namespace.slice(1);
    const nerveEnum = `${namespaceCapitalized}Nerve`;
    const anatomyEnum = `${namespaceCapitalized}AnatomicalRegion`;
    const nerveMap = {};

    function processNerve(entry) {
        let nerve = {
            id: entry.id,
            regions: entry.regions,
            uplink: [],
            downlink: entry.links || [],
        }
        nerveMap[entry.id] = nerve;
    }

    config.sections.forEach(processNerve);
    const allNerves = [...Object.values(nerveMap)];
    allNerves.forEach(n => {
        n.downlink.forEach(did => {
            if(!nerveMap[did]) {
                console.error(`Invalid nerve link defined from '${n.id}' to '${did}'`);
                process.exit();
            }
            nerveMap[did].uplink.push(n.id);
        });
    });

    fs.writeFileSync(path.join(configPath, '..', config.path), `
/*
 * THIS FILE IS AUTOMATICALLY GENERATED.
 * SOURCE: config/${namespace}/nervous_system.yaml
 */
use std::collections::HashSet;
use std::sync::OnceLock;
use crate::sim::layer::nervous::{Nerve, NerveIter};
use crate::sim::layer::AnatomicalRegionIter;
use super::${namespaceCapitalized}AnatomicalRegion;

#[derive(Debug, Display, Hash, Clone, Copy, PartialEq, Eq, EnumString, IntoStaticStr)]
pub enum ${nerveEnum} {
    ${Object.keys(nerveMap).join(',\n    ')},
}

static TERMINAL_NERVES: OnceLock<Vec<${nerveEnum}>> = OnceLock::new();
${allNerves.map(n => `
static ${n.id.toUpperCase()}_UPLINK: OnceLock<Vec<${nerveEnum}>> = OnceLock::new();
static ${n.id.toUpperCase()}_DOWNLINK: OnceLock<Vec<${nerveEnum}>> = OnceLock::new();
static ${n.id.toUpperCase()}_REGIONS: OnceLock<HashSet<${namespaceCapitalized}AnatomicalRegion>> = OnceLock::new();
`).join('')}

impl Nerve for ${nerveEnum} {
    type AnatomyType = ${anatomyEnum};

    fn terminal_nerves<'a>() -> NerveIter<'a, Self> {
        NerveIter(TERMINAL_NERVES.get_or_init(|| {
            let mut nerve_list = Vec::new();
            ${allNerves
                .filter(n => n.downlink.length == 0)
                .map(n => `nerve_list.push(${nerveEnum}::${n.id});`)
                .join('\n               ')}
            nerve_list
        }).iter())
    }
    fn uplink<'a>(&self) -> NerveIter<'a, Self> {
        match self {
            ${allNerves.map(n => `
            ${nerveEnum}::${n.id} => NerveIter(${n.id.toUpperCase()}_UPLINK.get_or_init(|| {
                ${n.uplink.length ? `
                let mut nerve_list = Vec::new();
                ${n.uplink.map(x => `nerve_list.push(${nerveEnum}::${x});`)
                .join('\n                ')}
                nerve_list
                ` : `Vec::new()`
                }
            }).iter())`
            )}
        }
    }
    fn downlink<'a>(&self) -> NerveIter<'a, Self> {
        match self {
            ${allNerves.map(n => `
            ${nerveEnum}::${n.id} => NerveIter(${n.id.toUpperCase()}_DOWNLINK.get_or_init(|| {
                ${n.downlink.length ? `
                let mut nerve_list = Vec::new();
                ${n.downlink.map(x => `nerve_list.push(${nerveEnum}::${x});`)
                .join('\n                ')}
                nerve_list
                ` : `Vec::new()`}
            }).iter())`
            )}
        }
    }
    fn regions<'a>(&self) -> AnatomicalRegionIter<Self::AnatomyType> {
        match self {
            ${allNerves.map(n => `
            ${nerveEnum}::${n.id} => AnatomicalRegionIter(${n.id.toUpperCase()}_REGIONS.get_or_init(|| {
                let mut region_list = HashSet::new();
                ${n.regions.map(x => `region_list.insert(${namespaceCapitalized}AnatomicalRegion::${x});`)
                .join('\n                ')}
                region_list
            }).iter())`
            )}
        }
    }
}
    `)
}
