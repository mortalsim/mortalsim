
const yaml = require('yaml');
const fs = require('fs');
const path = require('path');

const rootPath = path.join(__dirname, '..');
const layerPath = path.join(rootPath, 'src', 'sim', 'layer');
const registryPath = path.join(rootPath, 'src', 'sim', 'component', 'registry.rs');
const managerPath = path.join(rootPath, 'src', 'sim', 'layer', 'layer_manager.rs');

Object.defineProperty(String.prototype, 'cap', {
  value: function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
  },
  enumerable: false
});

// Start with core to make sure it's always the first one
const layerList = ["core"];

fs.readdirSync(layerPath)
    .filter(f => fs.statSync(path.join(layerPath, f)).isDirectory())
    .forEach(dir => {
        console.log(dir);
        if(!layerList.includes(dir)) {
            layerList.push(dir);
        }
    });

function combos(list) {
     var fn = function(active, rest, a) {
        if (!active.length && !rest.length)
            return;
        if (!rest.length) {
            // Don't include the full list
            if(active.length < layerList.length) {
                a.push(active);
            }
        } else {
            fn([...active, ...rest.slice(0, 1)], rest.slice(1), a);
            fn(active, rest.slice(1), a);
        }
        return a;
    }
    return fn([], list, []);
}

const layerCombos = combos(layerList);
const layerCoreCombos = [layerList, ...layerCombos.filter(x => x.includes('core'))];

const layerMap = {};

layerList.forEach(layer => {
    layerMap[layer] = [];
});

layerCombos.forEach(clayers => {
    layerList.forEach(layer => {
        if(clayers.includes(layer)) {
            layerMap[layer].push(clayers);
        }
    })
});

function getWrapperName(list) {
    return `${list.map(l => l.cap()).join('')}Wrapper`
}

function layersToBounds(list) {
    return `${list.map(l => `${l.cap()}Component<O>`).join(' + ')}`;
}

function layerImpl(wrapperName, impls, noimpls) {
    return `
${impls.map(impl => `
impl<O: Organism + 'static, T: Send + ${layersToBounds(impls)}> ${impl.cap()}Component<O> for ${wrapperName}<O, T> {
    fn ${impl}_init(&mut self, initializer: &mut ${impl.cap()}Initializer<O>) {
        self.0.${impl}_init(initializer)
    }
    fn ${impl}_connector(&mut self) -> &mut ${impl.cap()}Connector<O> {
        self.0.${impl}_connector()
    }
}
`).join('')}

${noimpls.map(impl => `
impl<O: Organism + 'static, T: Send + ${layersToBounds(impls)}> ${impl.cap()}Component<O> for ${wrapperName}<O, T> {
    fn ${impl}_init(&mut self, _initializer: &mut ${impl.cap()}Initializer<O>) {
        panic!("Improper wrapper method called!")
    }
    fn ${impl}_connector(&mut self) -> &mut ${impl.cap()}Connector<O> {
        panic!("Improper wrapper method called!")
    }
}
`).join('')}
`
}

fs.writeFileSync(registryPath, `
/*
 * THIS FILE IS AUTOMATICALLY GENERATED.
 * SOURCE: scripts/registry_generator.js
 */

use std::marker::PhantomData;
use std::collections::HashSet;
use crate::sim::organism::Organism;
use crate::sim::layer::{
    LayerType,
${layerList.map(l =>
`    ${l.cap()}Component,
    ${l.cap()}Initializer,
    ${l.cap()}Connector`).join(',\n')},
};
use super::SimComponent;

pub trait ComponentWrapper<O: Organism>: SimComponent<O> + ${layerList.map(l => `${l.cap()}Component<O>`).join(' + ')} {
${layerList.map(layer => `
    fn is_${layer}_component(&self) -> bool;
`).join('')}
    fn has_layer(&self, layer_type: &LayerType) -> bool;
}

impl<O: Organism> ComponentWrapper<O> for Box<dyn ComponentWrapper<O>> {
${layerList.map(layer => `
    fn is_${layer}_component(&self) -> bool {
        self.as_ref().is_${layer}_component()
    }
`).join('')}
    fn has_layer(&self, layer_type: &LayerType) -> bool {
        self.as_ref().has_layer(layer_type)
    }
}

impl<O: Organism> SimComponent<O> for Box<dyn ComponentWrapper<O>> {
    fn id(&self) -> &'static str {
        self.as_ref().id()
    }
    fn attach(self, _registry: &mut ComponentRegistry<O>) {
        panic!("Can't reattach a boxed component wrapper")
    }
    fn run(&mut self) {
        self.as_mut().run()     
    }
}
${layerList.map(layer => `
impl<O: Organism> ${layer.cap()}Component<O> for Box<dyn ComponentWrapper<O>> {
    fn ${layer}_init(&mut self, initializer: &mut ${layer.cap()}Initializer<O>) {
        self.as_mut().${layer}_init(initializer) 
    }
    fn ${layer}_connector(&mut self) -> &mut ${layer.cap()}Connector<O> {
        self.as_mut().${layer}_connector() 
    }
}`
).join('')}
${layerCombos.map(items => {
    let wrapperName = getWrapperName(items);
    return `
pub struct ${wrapperName}<O: Organism, T: Send + ${layersToBounds(items)} + 'static>(pub T, pub PhantomData<O>);

impl<O: Organism + 'static, T: Send + ${layersToBounds(items)}> SimComponent<O> for ${wrapperName}<O, T> {
    fn id(&self) -> &'static str {
        self.0.id()
    }
    fn attach(self, registry: &mut ComponentRegistry<O>) {
        self.0.attach(registry)
    }
    fn run(&mut self) {
        self.0.run();
    }
}
${layerImpl(wrapperName, items, layerList.filter(l => !items.includes(l)))}
impl<O: Organism + 'static, T: Send + ${layersToBounds(items)}> ComponentWrapper<O> for ${wrapperName}<O,T> {
${layerList.map(layer => `
    fn is_${layer}_component(&self) -> bool {
        ${items.includes(layer)}
    }
`).join('')}
    fn has_layer(&self, layer_type: &LayerType) -> bool {
        match layer_type {
${layerList.map(layer => `
            LayerType::${layer.cap()} => ${items.includes(layer)},
`).join('')}
        }
    }
}
`
}).join('')}

pub struct ComponentRegistry<O: Organism> {
    id_set: HashSet<&'static str>,
    components: Vec<Box<dyn ComponentWrapper<O>>>,
}

impl<O: Organism + 'static> ComponentRegistry<O> {
    pub fn new() -> Self {
        Self {
            id_set: HashSet::new(),
            components: Vec::new(),
        }
    }

    pub(crate) fn add_component(&mut self, component: impl SimComponent<O>) -> anyhow::Result<&'_ dyn ComponentWrapper<O>> {
        if self.id_set.contains(&component.id()) {
            return Err(anyhow!("Component '{}' has already been registered!", component.id()))
        }
        self.id_set.insert(component.id());
        component.attach(self);
        Ok(self.components.last().unwrap().as_ref())
    }

    pub(crate) fn remove_component(&mut self, component_id: &str) -> anyhow::Result<Box<dyn ComponentWrapper<O>>> {
        if let Some(index) = self.components.iter().position(|x| x.id() == component_id) {
            return Ok(self.components.remove(index))
        }
        Err(anyhow!("component not found"))
    }

    pub(crate) fn has_component(&self, component_id: &str) -> bool {
        self.id_set.contains(component_id)
    }
    pub(crate) fn all_components(&self) -> impl Iterator<Item = &Box<dyn ComponentWrapper<O>>> {
        self.components.iter()
    }
    pub(crate) fn all_components_mut(&mut self) -> impl Iterator<Item = &mut Box<dyn ComponentWrapper<O>>> {
        self.components.iter_mut()
    }
${layerCombos.map(items => `
    pub fn add_${items.join('_')}_component(&mut self, component: impl ${layersToBounds(items)} + 'static) {
        self.components.push(Box::new(${getWrapperName(items)}(component, PhantomData)))
    }
`).join('')}
}
`)

// fs.writeFileSync(managerPath, `
// use crate::sim::{Organism, SimConnector};
// use crate::sim::layer::SimLayer;
// use crate::sim::component::registry::{ComponentWrapper, ComponentRegistry};
// use crate::sim::component::{SimComponent, SimComponentProcessor};

// ${layerList.map(layer => `use super::${layer}::${layer.cap()}Layer;
// `).join('')}

// ${layerCoreCombos.map(items => {
//     const managerName = items.length == layerList.length ? '' : items.map(l => l.cap()).join('');
//     const notSupported = layerList.filter(x => !items.includes(x));
//     return `
// pub struct ${managerName}LayerManager<O: Organism> {
//     registry: ComponentRegistry<O>,
// ${items.map(layer => 
// `    ${layer}_layer: ${layer.cap()}Layer<O>,
// `).join('')}
// }

// impl<O: Organism + 'static> ${managerName}LayerManager<O> {
//     pub fn new() -> Self {
//         Self {
//             registry: ComponentRegistry::new(),
// ${items.map(layer =>
// `            ${layer}_layer: ${layer.cap()}Layer::new(),
// `).join('')}
//         }
//     }

//     pub fn add_component(&mut self, component: impl SimComponent<O>) -> anyhow::Result<()> {
//         let wrapper = Box::new(component);
//         ${notSupported.length ? `
//         if ${notSupported.map(x => `wrapper.is_${x}_component()`).join(' || ')} {
//             return Err(anyhow!("component types [${notSupported}] are not supported"));
//         }` : ''}

//         self.registry.add_component(wrapper)
//     }
    
//     pub fn remove_component(&mut self, component_id: &'static str) -> anyhow::Result<()> {
//         match self.registry.remove_component(component_id) {
//             Ok(_) => Ok(()),
//             Err(msg) => Err(msg),
//         }
//     }

//     pub fn update(&mut self, connector: &mut SimConnector) {
//     ${items.map(layer => `
//         self.${layer}_layer.pre_exec(connector);`
//     ).join('')}
//         let mut update_list = Vec::new();

//         for component in self.registry.all_components_mut() {
//             if ${items.map(layer=> `
//                 ${items.length > 1 ? '(' : ''} component.is_${layer}_component() &&
//                     self.${layer}_layer.check_component(component) ${items.length > 1 ? ')' : ''}`
//                 ).join(' ||')} {
//                 update_list.push(component);
//             }
//         }

//         for component in update_list {
//             // Prepare the component with each of the associated layers
//     ${items.map(layer => `
//             if component.is_${layer}_component() {
//                 self.${layer}_layer.prepare_component(connector, component);
//             }`
//     ).join('')}

//             // Execute component logic
//             component.run();

//     ${items.map(layer => `
//             if component.is_${layer}_component() {
//                 self.${layer}_layer.process_component(connector, component);
//             }`
//     ).join('')}
//         }
//     ${items.map(layer => `
//         self.${layer}_layer.post_exec(connector);`
//     ).join('')}
//     }
// }
// `
// }).join('')}
// `)