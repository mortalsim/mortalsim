const yaml = require('yaml');
const fs = require('fs');
const path = require('path');

const configPath = path.join(__dirname, '..', 'config');

fs.readdirSync(configPath)
    .filter(f => fs.statSync(path.join(configPath, f)).isDirectory())
    .forEach(dir => {
        console.log(dir);
        let configFile = fs.readFileSync(path.join(configPath, dir, 'nervous_system.yaml'), 'utf8');
        let config = yaml.parse(configFile);
        writeNeuralFile(dir, config);
    });

function writeNeuralFile(namespace, config) {
    let namespaceCapitalized = namespace.charAt(0).toUpperCase() + namespace.slice(1);
    let nerveEnum = `${namespaceCapitalized}Nerve`;
    let anatomyEnum = `${namespaceCapitalized}AnatomicalRegion`;
    let nerveMap = {};

    function processNerve(entry, upstream) {
        let nerve = {
            id: entry.id,
            regions: entry.regions,
            uplink: upstream ? [upstream.id] : [],
            downlink: entry.links || [],
        }
        nerveMap[entry.id] = nerve;
    }

    config.sections.forEach(e => processNerve(e, null, 0));

    let allNerves = [...Object.values(nerveMap)];

    fs.writeFileSync(path.join(configPath, '..', config.path), `
/*
 * THIS FILE IS AUTOMATICALLY GENERATED.
 * SOURCE: config/${namespace}/nervous_system.yaml
 */
use std::collections::HashSet;
use crate::sim::layer::nervous::{Nerve, NerveIter};
use crate::sim::layer::AnatomicalRegionIter;
use super::${namespaceCapitalized}AnatomicalRegion;

#[derive(Debug, Display, Hash, Clone, Copy, PartialEq, Eq, EnumString, IntoStaticStr)]
pub enum ${nerveEnum} {
    ${Object.keys(nerveMap).join(',\n    ')},
}

lazy_static! {
    static ref TERMINAL_NERVES: Vec<${nerveEnum}> = {
        let mut nerve_list = Vec::new();
        ${allNerves
            .filter(a => a.downlink.length == 0)
            .map(a => `nerve_list.push(${nerveEnum}::${a.id});`)
            .join('\n        ')}
        nerve_list
    };
}

${allNerves.map(n => `
lazy_static! {
    static ref ${n.id.toUpperCase()}_UPLINK: Vec<${nerveEnum}> = {
        ${n.uplink.length > 0 ? `let mut nerve_list = Vec::new();
        ${n.uplink.map(x => `nerve_list.push(${nerveEnum}::${x});`).join('\n        ')}
        nerve_list
        ` :
        `Vec::new()`}
    };
}
`).join('')}

${allNerves.filter(n => n.downlink).map(n => `
lazy_static! {
    static ref ${n.id.toUpperCase()}_DOWNLINK: Vec<${nerveEnum}> = {
        ${n.downlink.length > 0 ? `let mut nerve_list = Vec::new();
        ${n.downlink.map(x => `nerve_list.push(${nerveEnum}::${x});`).join('\n        ')}
        nerve_list
        ` :
        `Vec::new()`}
    };
}
`).join('')}

${allNerves.map(n => `
lazy_static! {
    static ref ${n.id.toUpperCase()}_REGIONS: HashSet<${anatomyEnum}> = {
        let mut region_list = HashSet::new();
        ${n.regions.map(x => `region_list.insert(${anatomyEnum}::${x});`).join('\n        ')}
        region_list
    };
}
`).join('')}

impl Nerve for ${nerveEnum} {
    type AnatomyType = ${anatomyEnum};

    fn terminal_nerves<'a>() -> NerveIter<'a, Self> {
        NerveIter(TERMINAL_NERVES.iter())
    }
    fn uplink<'a>(&self) -> NerveIter<'a, Self> {
        match self {
            ${allNerves.map(v => `
            ${nerveEnum}::${v.id} => NerveIter(${v.id.toUpperCase()}_UPLINK.iter())`
            )}
        }
    }
    fn downlink<'a>(&self) -> NerveIter<'a, Self> {
        match self {
            ${allNerves.map(v => `
            ${nerveEnum}::${v.id} => NerveIter(${v.id.toUpperCase()}_DOWNLINK.iter())`
            )}
        }
    }
    fn regions<'a>(&self) -> AnatomicalRegionIter<Self::AnatomyType> {
        match self {
            ${allNerves.map(v => `
            ${nerveEnum}::${v.id} => AnatomicalRegionIter(${v.id.toUpperCase()}_REGIONS.iter())`
            )}
        }
    }
}
    `)
}
